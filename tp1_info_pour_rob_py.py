# -*- coding: utf-8 -*-
"""TP1 Info pour ROB.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1snjBZu4mQX5SSzHyYkyIZ9ANKoo-moJG
"""

import math

# ============================================================
# Exercice 1
# ============================================================

# Question 1 : Fonction de distance robuste
def distance_robuste(val1: float, val2: float, val3: float):
    """
    Calcule une distance robuste à partir de trois valeurs numériques.

    Étapes :
    1. Trie les trois valeurs et récupère la médiane.
    2. Élimine les valeurs trop éloignées par rapport à la médiane :
       - Si la plus petite est < 0.5 * médiane → on l’élimine.
       - Si la plus grande est > 1.5 * médiane → on l’élimine.
    3. Calcule et retourne la moyenne des valeurs restantes.

    Args:
        val1 (float): Première valeur
        val2 (float): Deuxième valeur
        val3 (float): Troisième valeur

    Returns:
        float: Moyenne des valeurs conservées
    """
    L = [val1, val2, val3]
    L.sort()
    mediane = L[1]

    # Élimination des valeurs aberrantes
    if L[0] < 0.5 * mediane:
        L.pop(0)
        if L[1] > 1.5 * mediane:
            L.pop(1)
    elif L[2] > 1.5 * mediane:
        L.pop()

    # Moyenne des valeurs conservées
    distance = sum(L) / len(L)
    return distance


# Question 2 : Calcul du coût de déplacement
def cout_deplacement(coord_x1: int, coord_y1: int, coord_x2: int, coord_y2: int, terrain: str):
    """
    Calcule le coût du déplacement entre deux coordonnées
    en fonction du type de terrain.

    Args:
        coord_x1, coord_y1 (int): Coordonnées de départ
        coord_x2, coord_y2 (int): Coordonnées d’arrivée
        terrain (str): Type de terrain (R=route, H=herbe, S=sable, O=obstacle)

    Returns:
        float: Coût total du déplacement
    """
    distance = math.sqrt((coord_x2 - coord_x1) ** 2 + (coord_y2 - coord_y1) ** 2)
    couts = {'R': 1.0, 'H': 1.5, 'S': 2.0, 'O': 3.0}
    return distance * couts[terrain]


# Question 3 : Calcul du temps de trajet
def temps_trajet(coord_x1: int, coord_y1: int, coord_x2: int, coord_y2: int, terrain: str):
    """
    Calcule le temps nécessaire pour effectuer un trajet
    entre deux points selon le type de terrain.

    Args:
        coord_x1, coord_y1 (int): Coordonnées de départ
        coord_x2, coord_y2 (int): Coordonnées d’arrivée
        terrain (str): Type de terrain (R=route, H=herbe, S=sable, O=obstacle)

    Returns:
        float: Temps de trajet (secondes)
    """
    vitesses = {'R': 2, 'H': 1.5, 'S': 1, 'O': 0.5}
    distance = math.sqrt((coord_x2 - coord_x1) ** 2 + (coord_y2 - coord_y1) ** 2)
    return distance / vitesses[terrain]


# ============================================================
# Exercice 2 : Classe Position
# ============================================================

class Position:
    """
    Classe représentant une position dans un plan (x, y).
    """

    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __add__(self, autre: "Position"):
        """Surcharge de l’opérateur + pour additionner deux positions."""
        return Position(self.x + autre.x, self.y + autre.y)

    def afficher(self):
        """Affiche la position sous forme lisible."""
        print(f"Position(x={self.x}, y={self.y})")

    def distance_vers(self, autre: "Position"):
        """Calcule la distance euclidienne vers une autre position."""
        return math.sqrt((self.x - autre.x) ** 2 + (self.y - autre.y) ** 2)

    def __str__(self):
        return f"Position(x={self.x}, y={self.y})"


def distance_simple(coord_x1: int, coord_y1: int, coord_x2: int, coord_y2: int):
    """
    Calcule la distance euclidienne entre deux points (x1,y1) et (x2,y2).
    """
    return math.sqrt((coord_x2 - coord_x1) ** 2 + (coord_y2 - coord_y1) ** 2)


# ============================================================
# Exercice 3 : Classe Robot
# ============================================================

class Robot:
    """
    Classe représentant un robot qui peut se déplacer dans un plan.
    """

    def __init__(self, position=Position(0, 0)):
        self.position = position

    def __str__(self):
        return f"Robot à {self.position}"

    def afficher(self):
        print(self)

    def avancer_droite(self, n: int):
        """Déplace le robot vers la droite (+x)."""
        self.position.x += n

    def avancer_haut(self, n: int):
        """Déplace le robot vers le haut (+y)."""
        self.position.y += n

    def distance_vers_robot(self, autre: "Robot"):
        """Calcule la distance par rapport à un autre robot."""
        return distance_simple(self.position.x, self.position.y, autre.position.x, autre.position.y)

    def aller_vers(self, position_cible: Position):
        """Déplace directement le robot vers une position cible."""
        self.position = Position(position_cible.x, position_cible.y)


# ============================================================
# Exercice 4 : Classe Cible
# ============================================================

class Cible:
    """
    Classe représentant une cible dans le terrain.
    """

    def __init__(self, position: Position, nom: str):
        self.position = position
        self.nom = nom

    def est_atteinte_par(self, robot: Robot):
        """Renvoie True si le robot est exactement sur la cible."""
        return self.position.x == robot.position.x and self.position.y == robot.position.y

    def distance_depuis(self, robot: Robot):
        """Renvoie la distance entre la cible et le robot."""
        return self.position.distance_vers(robot.position)

    def afficher(self):
        print(f"Cible '{self.nom}' à {self.position}")


# ============================================================
# Exercice 5 : Classe Parcours
# ============================================================

class Parcours:
    """
    Classe représentant un parcours de plusieurs cibles
    qu’un robot doit visiter dans l’ordre.
    """

    def __init__(self, liste_cible=None, liste_visite=None):
        self.liste_cible = liste_cible if liste_cible is not None else []
        self.liste_visite = liste_visite if liste_visite is not None else []

    def nombre_cibles(self):
        """Renvoie le nombre total de cibles du parcours."""
        return len(self.liste_cible)

    def ajouter_cible(self, cible: Cible):
        """Ajoute une nouvelle cible au parcours (non visitée)."""
        self.liste_cible.append(cible)
        self.liste_visite.append(0)

    def cible_suivante(self):
        """Affiche la prochaine cible à visiter."""
        for i, visite in enumerate(self.liste_visite):
            if visite == 0:
                print("Prochaine cible :", self.liste_cible[i].nom)
                return
        print("Toutes les cibles ont été visitées.")

    def afficher(self):
        """Affiche la liste des cibles à visiter."""
        print("Cibles à visiter :")
        for cible in self.liste_cible:
            print("-", cible.nom)

    def executer_parcours(self, robot: Robot):
        """Fait visiter toutes les cibles au robot (dans l’ordre)."""
        for i, cible in enumerate(self.liste_cible):
            robot.aller_vers(cible.position)
            self.liste_visite[i] = 1


# ============================================================
# Exercice 6 : Classe Terrain
# ============================================================

class Terrain:
    """
    Classe représentant un terrain avec plusieurs robots
    et un parcours de cibles à effectuer.
    """

    def __init__(self):
        self.robots = []
        self.parcours = None

    def ajouter_robot(self, robot: Robot):
        """Ajoute un robot dans le terrain."""
        self.robots.append(robot)

    def definir_parcours(self, parcours: Parcours):
        """Associe un parcours aux robots du terrain."""
        self.parcours = parcours

    def lancer_mission(self):
        """Lance le parcours pour tous les robots."""
        for robot in self.robots:
            self.parcours.executer_parcours(robot)

    def afficher_etat(self):
        """Affiche la position de tous les robots."""
        for i, robot in enumerate(self.robots, start=1):
            print(f"Robot {i} : {robot.position}")


# ============================================================
# Démonstration complète
# ============================================================

def demonstration_complete():
    """
    Démonstration de l’utilisation des classes :
    - Création d’un terrain avec des robots
    - Définition d’un parcours
    - Exécution de la mission
    - Affichage de l’état final
    """
    terrain = Terrain()

    robot1 = Robot(Position(3, 4))
    robot2 = Robot(Position(6, 8))

    terrain.ajouter_robot(robot1)
    terrain.ajouter_robot(robot2)

    parcours = Parcours()
    parcours.ajouter_cible(Cible(Position(2, 0), "Cible1"))
    parcours.ajouter_cible(Cible(Position(3, 4), "Cible2"))
    parcours.ajouter_cible(Cible(Position(6, 8), "Cible3"))

    terrain.definir_parcours(parcours)
    terrain.lancer_mission()
    terrain.afficher_etat()

# ============================================================
# TESTS
# ============================================================

print("Exercice 1 : ")
print("question 1 :")
print("test 1 :", distance_robuste(1.0, 15.0, 20.0))
print("test 2 :", distance_robuste(1.0, 2.0, 20.0))

print("question 2 :")
print("test 1 :", cout_deplacement(0, 0, 5, 0, 'R'))
print("test 2 :", cout_deplacement(0, 0, 3, 4, 'H'))
print("test 3 :", cout_deplacement(0, 0, 0, 2, 'S'))
print("test 4 :", cout_deplacement(1, 1, 1, 1, 'O'))

print("question 3 :")
print("test 1 :", temps_trajet(0, 0, 6, 8, 'R'), "s")
print("test 2 :", temps_trajet(0, 0, 3, 4, 'S'), "s")
print("test 3 :", temps_trajet(0, 0, 0, 1, 'O'), "s")

print("\nExercice 2 :")
pos1 = Position()
pos1.afficher()
pos2 = Position(3, 4)
pos2.afficher()
pos3 = pos1 + pos2
pos3.afficher()
if pos1.distance_vers(pos2) == 5.0:
    print("pos1.distance_vers(pos2) = 5.0 TRUE")

print("\nExercice 3 :")
robot = Robot()
robot.afficher()
robot.avancer_droite(3)
robot.avancer_haut(4)
robot.afficher()

robot1 = Robot(Position(0, 0))
robot2 = Robot(Position(3, 4))
robot1.afficher()
robot2.afficher()
print(robot1.distance_vers_robot(robot2))
robot1.aller_vers(Position(3, 4))
robot1.afficher()

print("\nExercice 5 :")
parcours = Parcours()
parcours.ajouter_cible(Cible(Position(2, 0), "Point A"))
parcours.ajouter_cible(Cible(Position(2, 3), "Point B"))
parcours.ajouter_cible(Cible(Position(5, 3), "Point C"))

print("le nombre de parcours est", parcours.nombre_cibles())
parcours.cible_suivante()
parcours.afficher()
parcours.executer_parcours(robot)
print("Dernière cible atteinte ?", parcours.liste_cible[-1].est_atteinte_par(robot))

print("\nExercice 6 : Test de demonstration_complete()")
demonstration_complete()